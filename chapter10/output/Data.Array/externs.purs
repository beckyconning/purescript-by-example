-- Generated by psc-make version 0.6.9.3
module Data.Array where
import Prelude ()
import Data.Array ()
import Data.Maybe ()
import Prim ()
import Prelude ()
import Control.Alt ()
import Control.Plus ()
import Control.Alternative ()
import Control.MonadPlus ()
import Data.Maybe ()
import Prelude.Unsafe ()
infixl 8 !!
infix 5 \\
infix 8 ..
--  | Append an element to the end of an array, creating a new array.
--  | Get the number of elements in an array
--  | Find the first index for which a predicate holds,
--  | or `-1` if no such element exists
--  | Find the last index for which a predicate holds,
--  | or `-1` if no such element exists
--  | Concatenate two arrays, creating a new array
--  | Flatten an array of arrays, creating a new array
--  | Reverse an array, creating a copy
--  | Drop a number of elements from the start of an array, creating a new array.
--  | Create a copy of a subarray
--  | Insert an element at the specified index, creating a new array.
--  | Delete the element at the specified index, creating a new array.
--  | Change the element at the specified index, creating a new array.
--  | Apply a function to each element in an array, and flatten the results
--  | into a single, new array.
--  | Apply a function to each element in an array, creating a new array.
--  | Filter an array, keeping the elements which satisfy a predicate function,
--  | creating a new array.
--  | Create an array containing a range of numbers, including both endpoints.
--  | Apply a function to pairs of elements at the same index in two arrays,
--  | collecting the results in a new array.
--  |
--  | If one array is longer, elements will be discarded from the longer array.
--  |
--  | For example
--  |
--  | ```purescript
--  | zipWith (*) [1, 2, 3] [4, 5, 6, 7] == [4, 10, 18]
--  | ```
--  | Create an array with repeated instances of a value.
--  | An infix synonym for `range`.
--  | This operator provides a safe way to read a value at a particular index from an array.
--  |
--  | This function returns `Nothing` if the index is out-of-bounds.
--  |
--  | `Data.Array.Unsafe` provides the `unsafeIndex` function, which is an unsafe version of
--  | this function without bounds checking.
--  | Keep only a number of elements from the start of an array, creating a new array.
--  | Get all but the first element of an array, creating a new array, or `Nothing` if the array is empty
--  |
--  | Running time: `O(n)` where `n` is the length of the array
--  | Split an array into two parts:
--  |
--  | 1. the longest initial subarray for which all element satisfy the specified predicate
--  | 2. the remaining elements
--  |
--  | For example,
--  |
--  | ```purescript
--  | span (\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }
--  | ```
--  | Calculate the longest initial subarray for which all element satisfy the specified predicate,
--  | creating a new array.
--  | Sort the elements of an array in increasing order, where elements are compared using
--  | the specified partial ordering, creating a new array.
--  | Sort the elements of an array in increasing order, creating a new array.
--  | Create an array of one element
--  | Test whether an array is empty.
--  | Remove the duplicates from an array, where element equality is determined by the
--  | specified equivalence relation, creating a new array.
--  | Remove the duplicates from an array, creating a new array.
--  | Apply a function to the element at the specified index, creating a new array.
--  | Apply a function to each element in an array, keeping only the results which
--  | contain a value, creating a new array.
--  | Get the last element in an array, or `Nothing` if the array is empty
--  |
--  | Running time: `O(1)`.
--  | Calculate the intersection of two arrays, using the specified equivalence relation
--  | to compare elements, creating a new array.
--  | Calculate the intersection of two arrays, creating a new array.
--  | Get all but the last element of an array, creating a new array, or `Nothing` if the array is empty.
--  |
--  | Running time: `O(n)` where `n` is the length of the array
--  | Get the first element in an array, or `Nothing` if the array is empty
--  |
--  | Running time: `O(1)`.
--  | Group equal, consecutive elements of an array into arrays, using the specified
--  | equivalence relation to detemine equality.
--  | Group equal, consecutive elements of an array into arrays.
--  |
--  | For example,
--  |
--  | ```purescript
--  | group [1,1,2,2,1] == [[1,1],[2,2],[1]]
--  | ```
--  | Sort and group the elements of an array into arrays.
--  |
--  | For example,
--  |
--  | ```purescript
--  | group [1,1,2,2,1] == [[1,1,1],[2,2]]
--  | ```
--  | Find the index of the last element equal to the specified element,
--  | or `-1` if no such element exists
--  | Find the index of the first element equal to the specified element,
--  | or `-1` if no such element exists
--  | Remove the longest initial subarray for which all element satisfy the specified predicate,
--  | creating a new array.
--  | Delete the first element of an array which matches the specified value, under the
--  | equivalence relation provided in the first argument, creating a new array.
--  | Delete the first element of an array which is equal to the specified value,
--  | creating a new array.
--  | Delete the first occurrence of each element in the second array from the first array,
--  | creating a new array.
--  | Filter an array of optional values, keeping only the elements which contain
--  | a value, creating a new array.
foreign import replicate :: forall a. Prim.Number -> a -> [a]
foreign import takeWhile :: forall a. (a -> Prim.Boolean) -> [a] -> [a]
foreign import dropWhile :: forall a. (a -> Prim.Boolean) -> [a] -> [a]
foreign import span :: forall a. (a -> Prim.Boolean) -> [a] -> { rest :: [a], init :: [a] }
foreign import groupBy :: forall a. (a -> a -> Prim.Boolean) -> [a] -> [[a]]
foreign import group' :: forall a. (Prelude.Ord a) => [a] -> [[a]]
foreign import group :: forall a. (Prelude.Eq a) => [a] -> [[a]]
foreign import sortBy :: forall a. (a -> a -> Prelude.Ordering) -> [a] -> [a]
foreign import sort :: forall a. (Prelude.Ord a) => [a] -> [a]
foreign import nubBy :: forall a. (a -> a -> Prim.Boolean) -> [a] -> [a]
foreign import nub :: forall a. (Prelude.Eq a) => [a] -> [a]
foreign import zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
foreign import range :: Prim.Number -> Prim.Number -> [Prim.Number]
foreign import filter :: forall a. (a -> Prim.Boolean) -> [a] -> [a]
foreign import concatMap :: forall a b. (a -> [b]) -> [a] -> [b]
foreign import intersect :: forall a. (Prelude.Eq a) => [a] -> [a] -> [a]
foreign import intersectBy :: forall a. (a -> a -> Prim.Boolean) -> [a] -> [a] -> [a]
foreign import (\\) :: forall a. (Prelude.Eq a) => [a] -> [a] -> [a]
foreign import delete :: forall a. (Prelude.Eq a) => a -> [a] -> [a]
foreign import deleteBy :: forall a. (a -> a -> Prim.Boolean) -> a -> [a] -> [a]
foreign import modifyAt :: forall a. Prim.Number -> (a -> a) -> [a] -> [a]
foreign import updateAt :: forall a. Prim.Number -> a -> [a] -> [a]
foreign import deleteAt :: forall a. Prim.Number -> Prim.Number -> [a] -> [a]
foreign import insertAt :: forall a. Prim.Number -> a -> [a] -> [a]
foreign import take :: forall a. Prim.Number -> [a] -> [a]
foreign import drop :: forall a. Prim.Number -> [a] -> [a]
foreign import reverse :: forall a. [a] -> [a]
foreign import concat :: forall a. [[a]] -> [a]
foreign import append :: forall a. [a] -> [a] -> [a]
foreign import elemLastIndex :: forall a. (Prelude.Eq a) => a -> [a] -> Prim.Number
foreign import elemIndex :: forall a. (Prelude.Eq a) => a -> [a] -> Prim.Number
foreign import findLastIndex :: forall a. (a -> Prim.Boolean) -> [a] -> Prim.Number
foreign import findIndex :: forall a. (a -> Prim.Boolean) -> [a] -> Prim.Number
foreign import length :: forall a. [a] -> Prim.Number
foreign import catMaybes :: forall a. [Data.Maybe.Maybe a] -> [a]
foreign import mapMaybe :: forall a b. (a -> Data.Maybe.Maybe b) -> [a] -> [b]
foreign import map :: forall a b. (a -> b) -> [a] -> [b]
foreign import null :: forall a. [a] -> Prim.Boolean
foreign import init :: forall a. [a] -> Data.Maybe.Maybe [a]
foreign import tail :: forall a. [a] -> Data.Maybe.Maybe [a]
foreign import last :: forall a. [a] -> Data.Maybe.Maybe a
foreign import head :: forall a. [a] -> Data.Maybe.Maybe a
foreign import singleton :: forall a. a -> [a]
foreign import snoc :: forall a. [a] -> a -> [a]
foreign import (..) :: Prim.Number -> Prim.Number -> [Prim.Number]
foreign import (!!) :: forall a. [a] -> Prim.Number -> Data.Maybe.Maybe a
foreign import instance functorArray :: Prelude.Functor Prim.Array
foreign import instance applyArray :: Prelude.Apply Prim.Array
foreign import instance applicativeArray :: Prelude.Applicative Prim.Array
foreign import instance bindArray :: Prelude.Bind Prim.Array
foreign import instance monadArray :: Prelude.Monad Prim.Array
foreign import instance semigroupArray :: Prelude.Semigroup [a]
foreign import instance altArray :: Control.Alt.Alt Prim.Array
foreign import instance plusArray :: Control.Plus.Plus Prim.Array
foreign import instance alternativeArray :: Control.Alternative.Alternative Prim.Array
foreign import instance monadPlusArray :: Control.MonadPlus.MonadPlus Prim.Array
