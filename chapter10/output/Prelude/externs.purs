-- Generated by psc-make version 0.6.9.3
module Prelude where
import Prelude ()
import Prim ()
--  | The `Unit` type has a single inhabitant, called `unit`. It represents values with no computational content.
--  |
--  | `Unit` is often used, wrapped in a monadic type constructor, as the return type of a computation where only
--  | the _effects_ are important.
--  | The `Show` type class represents those types which can be converted into a human-readable `String` representation.
--  |
--  | While not required, it is recommended that for any expression `x`, the string `show x` be executable PureScript code
--  | which evaluates to the same value as the expression `x`.
--  | Addition and multiplication, satisfying the following laws:
--  |
--  | - `a` is a commutative monoid under addition
--  | - `a` is a monoid under multiplication
--  | - multiplication distributes over addition
--  | - multiplication by `zero` annihilates `a`
--  |
--  | A `Semigroupoid` is similar to a [`Category`](#category) but does not require an identity
--  | element `id`, just composable morphisms.
--  |
--  | `Semigroupoid`s should obey the following rule:
--  |
--  | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
--  |
--  | One example of a `Semigroupoid` is the function type constructor `(->)`, with `(<<<)` defined
--  | as function composition.
--  | The `Semigroup` type class identifies an associative operation on a type.
--  |
--  | `Semigroup` instances are required to satisfy the following law:
--  |
--  | - Associativity: `(x <> y) <> z = x <> (y <> z)`
--  |
--  | For example, the `String` type is an instance of `Semigroup`, where `(<>)` is defined to be string concatenation.
--  | Addition, multiplication, and subtraction.
--  |
--  | Has the same laws as `Semiring` but additionally satisfying:
--  |
--  | - `a` is an abelian group under addition
--  |
--  | The `Ordering` data type represents the three possible outcomes of comparing two values:
--  |
--  | `LT` - The first value is _less than_ the second.
--  | `GT` - The first value is _greater than_ the second.
--  | `EQ` - The first value is _equal to_ or _incomparable to_ the second.
--  | Addition, multiplication, modulo operation and division, satisfying:
--  |
--  | - ```a / b * b + (a `mod` b) = a```
--  |
--  | A `Functor` is a type constructor which supports a mapping operation `(<$>)`.
--  |
--  | `(<$>)` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return
--  | types use the type constructor `f` to represent some computational context.
--  |
--  | `Functor` instances should satisfy the following laws:
--  |
--  | - Identity: `(<$>) id = id`
--  | - Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`
--  |
--  | The `Eq` type class represents types which support decidable equality.
--  |
--  | `Eq` instances should satisfy the following laws:
--  |
--  | - Reflexivity: `x == x = true`
--  | - Symmetry: `x == y = y == x`
--  | - Transitivity: if `x == y` and `y == z` then `x == z`
--  | - Negation: `x /= y = not (x == y)`
--  |
--  | `(/=)` may be implemented in terms of `(==)`, but it might give a performance improvement to implement it separately.
--  | The `Ord` type class represents types which support comparisons.
--  |
--  | `Ord` instances should satisfy the laws of _partially orderings_:
--  |
--  | - Reflexivity: `a <= a`
--  | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
--  | - Transitivity: if `a <= b` and `b <= c` then `a <= c`
--  |
--  | Ring where every nonzero element has a multiplicative inverse so that:
--  |
--  | - ```a `mod` b = zero```
--  |
--  | A commutative field
--  | `Category`s consist of objects and composable morphisms between them, and as such are
--  | [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids` must have an identity element.
--  |
--  | `Category`s should obey the following rules.
--  |
--  | - Left Identity: `id <<< p = p`
--  | - Right Identity: `p <<< id = p`
--  |
--  | The `BoolLike` type class identifies types which support Boolean operations.
--  |
--  | `BoolLike` instances are required to satisfy the laws of a _Boolean algebra_.
--  |
--  | The `Bits` type class identifies types which support bitwise operations.
--  | The `Apply` class provides the `(<*>)` which is used to apply a function to an argument under a type constructor.
--  |
--  | `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor `f`.
--  | It might also be understood in terms of the `lift2` function:
--  |
--  | ```purescript
--  | lift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c
--  | lift2 f a b = f <$> a <*> b
--  | ```
--  |
--  | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts the function application operator `($)` to arguments
--  | wrapped with the type constructor `f`.
--  |
--  | `Apply` instances should satisfy the following law:
--  |
--  | - Associative Composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`
--  |
--  | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
--  | The `Bind` type class extends the [`Apply`](#apply) type class with a "bind" operation `(>>=)` which composes computations
--  | in sequence, using the return value of one computation to determine the next computation.
--  |
--  | The `>>=` operator can also be expressed using `do` notation, as follows:
--  |
--  | ```purescript
--  | x >>= f = do y <- x
--  |              f y
--  | ```
--  |
--  | where the function argument of `f` is given the name `y`.
--  |
--  | `Bind` instances should satisfy the following law:
--  |
--  | - Associativity: `(x >>= f) >>= g = x >>= (\k => f k >>= g)`
--  |
--  | Or, expressed using `do` notation:
--  |
--  | - Associativity: `do { z <- do { y <- x ; f y } ; g z } = do { k <- x ; do { y <- f k ; g y } }`
--  |
--  | Associativity tells us that we can regroup operations which use do-notation, so that we can unambiguously write, for example:
--  |
--  | ```purescript
--  | do x <- m1
--  |    y <- m2 x
--  |    m3 x y
--  | ```
--  | The `Applicative` type class extends the [`Apply`](#apply) type class with a `pure` function, which can be used to
--  | create values of type `f a` from values of type `a`.
--  |
--  | Where [`Apply`](#apply) provides the ability to lift functions of two or more arguments to functions whose arguments are wrapped using `f`,
--  | and [`Functor`](#functor) provides the ability to lift functions of one argument, `pure` can be seen as the function which lifts functions of
--  | _zero_ arguments. That is, `Applicative` functors support a lifting operation for any number of function arguments.
--  |
--  | `Applicative` instances should satisfy the following laws:
--  |
--  | - Identity: `(pure id) <*> v = v`
--  | - Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`
--  | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`
--  | - Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`
--  |
--  | The `Monad` type class combines the operations of the `Bind` and `Applicative` type classes. Therefore, `Monad` instances
--  | represent type constructors which support sequential composition, and also lifting of functions of arbitrary arity.
--  |
--  | `Monad` instances should satisfy the following laws:
--  |
--  | - Left Identity: `pure x >>= f = f x`
--  | - Right Identity: `x >>= pure = x`
--  |
--  | Or, expressed using `do` notation:
--  |
--  | - Left Identity: `do { y <- pure x ; f y } = f x`
--  | - Right Identity: `do { y <- x ; pure y } = x`
--  |
--  | A `Semigroupoid` is similar to a [`Category`](#category) but does not require an identity
--  | element `id`, just composable morphisms.
--  |
--  | `Semigroupoid`s should obey the following rule:
--  |
--  | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
--  |
--  | One example of a `Semigroupoid` is the function type constructor `(->)`, with `(<<<)` defined
--  | as function composition.
--  | `Category`s consist of objects and composable morphisms between them, and as such are
--  | [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids` must have an identity element.
--  |
--  | `Category`s should obey the following rules.
--  |
--  | - Left Identity: `id <<< p = p`
--  | - Right Identity: `p <<< id = p`
--  |
--  | The `Show` type class represents those types which can be converted into a human-readable `String` representation.
--  |
--  | While not required, it is recommended that for any expression `x`, the string `show x` be executable PureScript code
--  | which evaluates to the same value as the expression `x`.
--  | A `Functor` is a type constructor which supports a mapping operation `(<$>)`.
--  |
--  | `(<$>)` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return
--  | types use the type constructor `f` to represent some computational context.
--  |
--  | `Functor` instances should satisfy the following laws:
--  |
--  | - Identity: `(<$>) id = id`
--  | - Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`
--  |
--  | The `Apply` class provides the `(<*>)` which is used to apply a function to an argument under a type constructor.
--  |
--  | `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor `f`.
--  | It might also be understood in terms of the `lift2` function:
--  |
--  | ```purescript
--  | lift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c
--  | lift2 f a b = f <$> a <*> b
--  | ```
--  |
--  | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts the function application operator `($)` to arguments
--  | wrapped with the type constructor `f`.
--  |
--  | `Apply` instances should satisfy the following law:
--  |
--  | - Associative Composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`
--  |
--  | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
--  | The `Applicative` type class extends the [`Apply`](#apply) type class with a `pure` function, which can be used to
--  | create values of type `f a` from values of type `a`.
--  |
--  | Where [`Apply`](#apply) provides the ability to lift functions of two or more arguments to functions whose arguments are wrapped using `f`,
--  | and [`Functor`](#functor) provides the ability to lift functions of one argument, `pure` can be seen as the function which lifts functions of
--  | _zero_ arguments. That is, `Applicative` functors support a lifting operation for any number of function arguments.
--  |
--  | `Applicative` instances should satisfy the following laws:
--  |
--  | - Identity: `(pure id) <*> v = v`
--  | - Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`
--  | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`
--  | - Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`
--  |
--  | The `Bind` type class extends the [`Apply`](#apply) type class with a "bind" operation `(>>=)` which composes computations
--  | in sequence, using the return value of one computation to determine the next computation.
--  |
--  | The `>>=` operator can also be expressed using `do` notation, as follows:
--  |
--  | ```purescript
--  | x >>= f = do y <- x
--  |              f y
--  | ```
--  |
--  | where the function argument of `f` is given the name `y`.
--  |
--  | `Bind` instances should satisfy the following law:
--  |
--  | - Associativity: `(x >>= f) >>= g = x >>= (\k => f k >>= g)`
--  |
--  | Or, expressed using `do` notation:
--  |
--  | - Associativity: `do { z <- do { y <- x ; f y } ; g z } = do { k <- x ; do { y <- f k ; g y } }`
--  |
--  | Associativity tells us that we can regroup operations which use do-notation, so that we can unambiguously write, for example:
--  |
--  | ```purescript
--  | do x <- m1
--  |    y <- m2 x
--  |    m3 x y
--  | ```
--  | The `Monad` type class combines the operations of the `Bind` and `Applicative` type classes. Therefore, `Monad` instances
--  | represent type constructors which support sequential composition, and also lifting of functions of arbitrary arity.
--  |
--  | `Monad` instances should satisfy the following laws:
--  |
--  | - Left Identity: `pure x >>= f = f x`
--  | - Right Identity: `x >>= pure = x`
--  |
--  | Or, expressed using `do` notation:
--  |
--  | - Left Identity: `do { y <- pure x ; f y } = f x`
--  | - Right Identity: `do { y <- x ; pure y } = x`
--  |
--  | Addition and multiplication, satisfying the following laws:
--  |
--  | - `a` is a commutative monoid under addition
--  | - `a` is a monoid under multiplication
--  | - multiplication distributes over addition
--  | - multiplication by `zero` annihilates `a`
--  |
--  | Addition, multiplication, modulo operation and division, satisfying:
--  |
--  | - ```a / b * b + (a `mod` b) = a```
--  |
--  | Addition, multiplication, and subtraction.
--  |
--  | Has the same laws as `Semiring` but additionally satisfying:
--  |
--  | - `a` is an abelian group under addition
--  |
--  | Ring where every nonzero element has a multiplicative inverse so that:
--  |
--  | - ```a `mod` b = zero```
--  |
--  | A commutative field
--  | The `Eq` type class represents types which support decidable equality.
--  |
--  | `Eq` instances should satisfy the following laws:
--  |
--  | - Reflexivity: `x == x = true`
--  | - Symmetry: `x == y = y == x`
--  | - Transitivity: if `x == y` and `y == z` then `x == z`
--  | - Negation: `x /= y = not (x == y)`
--  |
--  | `(/=)` may be implemented in terms of `(==)`, but it might give a performance improvement to implement it separately.
--  | The `Ord` type class represents types which support comparisons.
--  |
--  | `Ord` instances should satisfy the laws of _partially orderings_:
--  |
--  | - Reflexivity: `a <= a`
--  | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
--  | - Transitivity: if `a <= b` and `b <= c` then `a <= c`
--  |
--  | The `Bits` type class identifies types which support bitwise operations.
--  | The `BoolLike` type class identifies types which support Boolean operations.
--  |
--  | `BoolLike` instances are required to satisfy the laws of a _Boolean algebra_.
--  |
--  | The `Semigroup` type class identifies an associative operation on a type.
--  |
--  | `Semigroup` instances are required to satisfy the following law:
--  |
--  | - Associativity: `(x <> y) <> z = x <> (y <> z)`
--  |
--  | For example, the `String` type is an instance of `Semigroup`, where `(<>)` is defined to be string concatenation.
infixr 9 >>>
infixr 9 <<<
infixr 0 $
infixl 0 #
infixr 6 :
infixl 4 <$>
infixl 1 <#>
infixl 4 <*>
infixl 1 >>=
infixl 7 *
infixl 7 /
infixl 7 %
infixl 6 -
infixl 6 +
infix 4 ==
infix 4 /=
infixl 4 <
infixl 4 >
infixl 4 <=
infixl 4 >=
infixl 10 .&.
infixl 10 .|.
infixl 10 .^.
infixr 2 ||
infixr 3 &&
infixr 5 <>
infixr 5 ++
--  | Attaches an element to the front of an array, creating a new array.
--  |
--  | ```purescript
--  | cons 1 [2, 3, 4] = [1, 2, 3, 4]
--  | ```
--  |
--  | Note, the running time of this function is `O(n)`.
--  | The `BoolLike` type class identifies types which support Boolean operations.
--  |
--  | `BoolLike` instances are required to satisfy the laws of a _Boolean algebra_.
--  |
--  | The `Bind` type class extends the [`Apply`](#apply) type class with a "bind" operation `(>>=)` which composes computations
--  | in sequence, using the return value of one computation to determine the next computation.
--  |
--  | The `>>=` operator can also be expressed using `do` notation, as follows:
--  |
--  | ```purescript
--  | x >>= f = do y <- x
--  |              f y
--  | ```
--  |
--  | where the function argument of `f` is given the name `y`.
--  |
--  | `Bind` instances should satisfy the following law:
--  |
--  | - Associativity: `(x >>= f) >>= g = x >>= (\k => f k >>= g)`
--  |
--  | Or, expressed using `do` notation:
--  |
--  | - Associativity: `do { z <- do { y <- x ; f y } ; g z } = do { k <- x ; do { y <- f k ; g y } }`
--  |
--  | Associativity tells us that we can regroup operations which use do-notation, so that we can unambiguously write, for example:
--  |
--  | ```purescript
--  | do x <- m1
--  |    y <- m2 x
--  |    m3 x y
--  | ```
--  | The `Eq` type class represents types which support decidable equality.
--  |
--  | `Eq` instances should satisfy the following laws:
--  |
--  | - Reflexivity: `x == x = true`
--  | - Symmetry: `x == y = y == x`
--  | - Transitivity: if `x == y` and `y == z` then `x == z`
--  | - Negation: `x /= y = not (x == y)`
--  |
--  | `(/=)` may be implemented in terms of `(==)`, but it might give a performance improvement to implement it separately.
--  | The `Semigroup` type class identifies an associative operation on a type.
--  |
--  | `Semigroup` instances are required to satisfy the following law:
--  |
--  | - Associativity: `(x <> y) <> z = x <> (y <> z)`
--  |
--  | For example, the `String` type is an instance of `Semigroup`, where `(<>)` is defined to be string concatenation.
--  | A `Semigroupoid` is similar to a [`Category`](#category) but does not require an identity
--  | element `id`, just composable morphisms.
--  |
--  | `Semigroupoid`s should obey the following rule:
--  |
--  | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
--  |
--  | One example of a `Semigroupoid` is the function type constructor `(->)`, with `(<<<)` defined
--  | as function composition.
--  | Forwards composition, or `(<<<)` with its arguments reversed.
--  | The `Apply` class provides the `(<*>)` which is used to apply a function to an argument under a type constructor.
--  |
--  | `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor `f`.
--  | It might also be understood in terms of the `lift2` function:
--  |
--  | ```purescript
--  | lift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c
--  | lift2 f a b = f <$> a <*> b
--  | ```
--  |
--  | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts the function application operator `($)` to arguments
--  | wrapped with the type constructor `f`.
--  |
--  | `Apply` instances should satisfy the following law:
--  |
--  | - Associative Composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`
--  |
--  | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
--  | A `Functor` is a type constructor which supports a mapping operation `(<$>)`.
--  |
--  | `(<$>)` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return
--  | types use the type constructor `f` to represent some computational context.
--  |
--  | `Functor` instances should satisfy the following laws:
--  |
--  | - Identity: `(<$>) id = id`
--  | - Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`
--  |
--  | `(<#>)` is `(<$>)` with its arguments reversed. For example:
--  |
--  | ```purescript
--  | [1, 2, 3] <#> \n -> n * n
--  | ```
--  | An infix alias for `cons`.
--  |
--  | Note, the running time of this function is `O(n)`.
--  | The `Eq` type class represents types which support decidable equality.
--  |
--  | `Eq` instances should satisfy the following laws:
--  |
--  | - Reflexivity: `x == x = true`
--  | - Symmetry: `x == y = y == x`
--  | - Transitivity: if `x == y` and `y == z` then `x == z`
--  | - Negation: `x /= y = not (x == y)`
--  |
--  | `(/=)` may be implemented in terms of `(==)`, but it might give a performance improvement to implement it separately.
--  | Addition, multiplication, modulo operation and division, satisfying:
--  |
--  | - ```a / b * b + (a `mod` b) = a```
--  |
--  | The `Bits` type class identifies types which support bitwise operations.
--  | The `Bits` type class identifies types which support bitwise operations.
--  | The `Bits` type class identifies types which support bitwise operations.
--  | Addition, multiplication, and subtraction.
--  |
--  | Has the same laws as `Semiring` but additionally satisfying:
--  |
--  | - `a` is an abelian group under addition
--  |
--  | `(++)` is an alias for `(<>)`.
--  | Addition and multiplication, satisfying the following laws:
--  |
--  | - `a` is a commutative monoid under addition
--  | - `a` is a monoid under multiplication
--  | - multiplication distributes over addition
--  | - multiplication by `zero` annihilates `a`
--  |
--  | Addition and multiplication, satisfying the following laws:
--  |
--  | - `a` is a commutative monoid under addition
--  | - `a` is a monoid under multiplication
--  | - multiplication distributes over addition
--  | - multiplication by `zero` annihilates `a`
--  |
--  | The `BoolLike` type class identifies types which support Boolean operations.
--  |
--  | `BoolLike` instances are required to satisfy the laws of a _Boolean algebra_.
--  |
--  | Applies a function to its argument
--  |
--  | ```purescript
--  | length $ groupBy productCategory $ filter isInStock products
--  | ```
--  |
--  | is equivalent to
--  |
--  | ```purescript
--  | length (groupBy productCategory (filter isInStock (products)))
--  | ```
--  |
--  | `($)` is different from [`(#)`](#-2) because it is right-infix instead of left, so
--  | `a $ b $ c $ d x` = `a $ (b $ (c $ (d $ x)))` = `a (b (c (d x)))`
--  |
--  | Applies a function to its argument
--  |
--  | ```purescript
--  | products # groupBy productCategory # filter isInStock # length
--  | ```
--  |
--  | is equivalent to
--  |
--  | ```purescript
--  | length (groupBy productCategory (filter isInStock (products)))
--  | ```
--  |
--  | `(#)` is different from [`($)`](#-1) because it is left-infix instead of right, so
--  | `x # a # b # c # d` = `(((x # a) # b) # c) # d` = `d (c (b (a x)))`
--  |
--  | The `Bits` type class identifies types which support bitwise operations.
--  | Addition and multiplication, satisfying the following laws:
--  |
--  | - `a` is a commutative monoid under addition
--  | - `a` is a monoid under multiplication
--  | - multiplication distributes over addition
--  | - multiplication by `zero` annihilates `a`
--  |
--  | `unit` is the sole inhabitant of the `Unit` type.
--  | The `Bits` type class identifies types which support bitwise operations.
--  | The `Show` type class represents those types which can be converted into a human-readable `String` representation.
--  |
--  | While not required, it is recommended that for any expression `x`, the string `show x` be executable PureScript code
--  | which evaluates to the same value as the expression `x`.
--  | The `Bits` type class identifies types which support bitwise operations.
--  | The `Applicative` type class extends the [`Apply`](#apply) type class with a `pure` function, which can be used to
--  | create values of type `f a` from values of type `a`.
--  |
--  | Where [`Apply`](#apply) provides the ability to lift functions of two or more arguments to functions whose arguments are wrapped using `f`,
--  | and [`Functor`](#functor) provides the ability to lift functions of one argument, `pure` can be seen as the function which lifts functions of
--  | _zero_ arguments. That is, `Applicative` functors support a lifting operation for any number of function arguments.
--  |
--  | `Applicative` instances should satisfy the following laws:
--  |
--  | - Identity: `(pure id) <*> v = v`
--  | - Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`
--  | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`
--  | - Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`
--  |
--  | `return` is an alias for `pure`.
--  | An alias for `true`, which can be useful in guard clauses:
--  |
--  | ```purescript
--  | max x y | x >= y = x
--  |         | otherwise = y
--  | ```
--  |
--  | Addition and multiplication, satisfying the following laws:
--  |
--  | - `a` is a commutative monoid under addition
--  | - `a` is a monoid under multiplication
--  | - multiplication distributes over addition
--  | - multiplication by `zero` annihilates `a`
--  |
--  | The `BoolLike` type class identifies types which support Boolean operations.
--  |
--  | `BoolLike` instances are required to satisfy the laws of a _Boolean algebra_.
--  |
--  | Addition, multiplication, modulo operation and division, satisfying:
--  |
--  | - ```a / b * b + (a `mod` b) = a```
--  |
--  | `liftM1` provides a default implementation of `(<$>)` for any [`Monad`](#monad),
--  | without using `(<$>)` as provided by the [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.
--  |
--  | `liftM1` can therefore be used to write [`Functor`](#functor) instances as follows:
--  |
--  | ```purescript
--  | instance functorF :: Functor F where
--  |   (<$>) = liftM1
--  | ```
--  | `liftA1` provides a default implementation of `(<$>)` for any [`Applicative`](#applicative) functor,
--  | without using `(<$>)` as provided by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass relationship.
--  |
--  | `liftA1` can therefore be used to write [`Functor`](#functor) instances as follows:
--  |
--  | ```purescript
--  | instance functorF :: Functor F where
--  |   (<$>) = liftA1
--  | ```
--  | `Category`s consist of objects and composable morphisms between them, and as such are
--  | [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids` must have an identity element.
--  |
--  | `Category`s should obey the following rules.
--  |
--  | - Left Identity: `id <<< p = p`
--  | - Right Identity: `p <<< id = p`
--  |
--  | Flips the order of the arguments to a function of two arguments.
--  |
--  | ```purescript
--  | flip const 1 2 = const 2 1 = 2
--  | ```
--  |
--  | Returns its first argument and ignores its second.
--  |
--  | ```purescript
--  | const 1 "hello" = 1
--  | ```
--  |
--  | The `void` function is used to ignore the type wrapped by a [`Functor`](#functor), replacing it with `Unit` and
--  | keeping only the type information provided by the type constructor itself.
--  |
--  | `void` is often useful when using `do` notation to change the return type of a monadic computation:
--  |
--  | ```purescript
--  | main = forE 1 10 \n -> void do
--  |   print n
--  |   print (n * n)
--  | ```
--  | The `Bits` type class identifies types which support bitwise operations.
--  | The `Ord` type class represents types which support comparisons.
--  |
--  | `Ord` instances should satisfy the laws of _partially orderings_:
--  |
--  | - Reflexivity: `a <= a`
--  | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
--  | - Transitivity: if `a <= b` and `b <= c` then `a <= c`
--  |
--  | Test whether one value is _strictly less than_ another.
--  | Test whether one value is _non-strictly less than_ another.
--  | Test whether one value is _strictly greater than_ another.
--  | Test whether one value is _non-strictly greater than_ another.
--  | This function returns its first argument, and can be used to assert type equalities.
--  | This can be useful when types are otherwise ambiguous.
--  |
--  | ```purescript
--  | main = print $ [] `asTypeOf` [0]
--  | ```
--  |
--  | If instead, we had written `main = print []`, the type of the argument `[]` would have
--  | been ambiguous, resulting in a compile-time error.
--  | `ap` provides a default implementation of `(<*>)` for any [`Monad`](#monad),
--  | without using `(<*>)` as provided by the [`Apply`](#apply)-[`Monad`](#monad) superclass relationship.
--  |
--  | `ap` can therefore be used to write [`Apply`](#apply) instances as follows:
--  |
--  | ```purescript
--  | instance applyF :: Apply F where
--  |   (<*>) = ap
--  | ```
newtype Unit = Unit {  }
data Ordering = LT  | GT  | EQ 
class Semigroup a where
  (<>) :: a -> a -> a
class BoolLike b where
  (&&) :: b -> b -> b
  (||) :: b -> b -> b
  not :: b -> b
class Bits b where
  (.&.) :: b -> b -> b
  (.|.) :: b -> b -> b
  (.^.) :: b -> b -> b
  shl :: b -> Prim.Number -> b
  shr :: b -> Prim.Number -> b
  zshr :: b -> Prim.Number -> b
  complement :: b -> b
class (Prelude.Eq a) <= Ord a where
  compare :: a -> a -> Prelude.Ordering
class Eq a where
  (==) :: a -> a -> Prim.Boolean
  (/=) :: a -> a -> Prim.Boolean
class (Prelude.DivisionRing a) <= Num a where
class (Prelude.Ring a, Prelude.ModuloSemiring a) <= DivisionRing a where
class (Prelude.Semiring a) <= Ring a where
  (-) :: a -> a -> a
class (Prelude.Semiring a) <= ModuloSemiring a where
  (/) :: a -> a -> a
  mod :: a -> a -> a
class Semiring a where
  (+) :: a -> a -> a
  zero :: a
  (*) :: a -> a -> a
  one :: a
class (Prelude.Applicative m, Prelude.Bind m) <= Monad m where
class (Prelude.Apply m) <= Bind m where
  (>>=) :: forall a b. m a -> (a -> m b) -> m b
class (Prelude.Apply f) <= Applicative f where
  pure :: forall a. a -> f a
class (Prelude.Functor f) <= Apply f where
  (<*>) :: forall a b. f (a -> b) -> f a -> f b
class Functor f where
  (<$>) :: forall a b. (a -> b) -> f a -> f b
class Show a where
  show :: a -> Prim.String
class (Prelude.Semigroupoid a) <= Category a where
  id :: forall t. a t t
class Semigroupoid a where
  (<<<) :: forall b c d. a c d -> a b c -> a b d
foreign import unit :: Prelude.Unit
foreign import (++) :: forall s. (Prelude.Semigroup s) => s -> s -> s
foreign import (>=) :: forall a. (Prelude.Ord a) => a -> a -> Prim.Boolean
foreign import (<=) :: forall a. (Prelude.Ord a) => a -> a -> Prim.Boolean
foreign import (>) :: forall a. (Prelude.Ord a) => a -> a -> Prim.Boolean
foreign import (<) :: forall a. (Prelude.Ord a) => a -> a -> Prim.Boolean
foreign import negate :: forall a. (Prelude.Ring a) => a -> a
foreign import (%) :: Prim.Number -> Prim.Number -> Prim.Number
foreign import ap :: forall m a b. (Prelude.Monad m) => m (a -> b) -> m a -> m b
foreign import liftM1 :: forall m a b. (Prelude.Monad m) => (a -> b) -> m a -> m b
foreign import return :: forall m a. (Prelude.Monad m) => a -> m a
foreign import liftA1 :: forall f a b. (Prelude.Applicative f) => (a -> b) -> f a -> f b
foreign import void :: forall f a. (Prelude.Functor f) => f a -> f Prelude.Unit
foreign import (<#>) :: forall f a b. (Prelude.Functor f) => f a -> (a -> b) -> f b
foreign import cons :: forall a. a -> [a] -> [a]
foreign import (:) :: forall a. a -> [a] -> [a]
foreign import (#) :: forall a b. a -> (a -> b) -> b
foreign import ($) :: forall a b. (a -> b) -> a -> b
foreign import (>>>) :: forall a b c d. (Prelude.Semigroupoid a) => a b c -> a c d -> a b d
foreign import asTypeOf :: forall a. a -> a -> a
foreign import const :: forall a b. a -> b -> a
foreign import flip :: forall a b c. (a -> b -> c) -> b -> a -> c
foreign import otherwise :: Prim.Boolean
foreign import instance semigroupoidArr :: Prelude.Semigroupoid Prim.Function
foreign import instance categoryArr :: Prelude.Category Prim.Function
foreign import instance showUnit :: Prelude.Show Prelude.Unit
foreign import instance showString :: Prelude.Show Prim.String
foreign import instance showBoolean :: Prelude.Show Prim.Boolean
foreign import instance showNumber :: Prelude.Show Prim.Number
foreign import instance showArray :: (Prelude.Show a) => Prelude.Show [a]
foreign import instance functorArr :: Prelude.Functor (Prim.Function r)
foreign import instance applyArr :: Prelude.Apply (Prim.Function r)
foreign import instance applicativeArr :: Prelude.Applicative (Prim.Function r)
foreign import instance bindArr :: Prelude.Bind (Prim.Function r)
foreign import instance monadArr :: Prelude.Monad (Prim.Function r)
foreign import instance semiringNumber :: Prelude.Semiring Prim.Number
foreign import instance ringNumber :: Prelude.Ring Prim.Number
foreign import instance moduloSemiringNumber :: Prelude.ModuloSemiring Prim.Number
foreign import instance divisionRingNumber :: Prelude.DivisionRing Prim.Number
foreign import instance numNumber :: Prelude.Num Prim.Number
foreign import instance eqUnit :: Prelude.Eq Prelude.Unit
foreign import instance eqString :: Prelude.Eq Prim.String
foreign import instance eqNumber :: Prelude.Eq Prim.Number
foreign import instance eqBoolean :: Prelude.Eq Prim.Boolean
foreign import instance eqArray :: (Prelude.Eq a) => Prelude.Eq [a]
foreign import instance eqOrdering :: Prelude.Eq Prelude.Ordering
foreign import instance showOrdering :: Prelude.Show Prelude.Ordering
foreign import instance semigroupOrdering :: Prelude.Semigroup Prelude.Ordering
foreign import instance ordUnit :: Prelude.Ord Prelude.Unit
foreign import instance ordBoolean :: Prelude.Ord Prim.Boolean
foreign import instance ordNumber :: Prelude.Ord Prim.Number
foreign import instance ordString :: Prelude.Ord Prim.String
foreign import instance ordArray :: (Prelude.Ord a) => Prelude.Ord [a]
foreign import instance bitsNumber :: Prelude.Bits Prim.Number
foreign import instance boolLikeBoolean :: Prelude.BoolLike Prim.Boolean
foreign import instance semigroupUnit :: Prelude.Semigroup Prelude.Unit
foreign import instance semigroupString :: Prelude.Semigroup Prim.String
foreign import instance semigroupArr :: (Prelude.Semigroup s') => Prelude.Semigroup (s -> s')
