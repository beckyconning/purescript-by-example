-- Generated by psc-make version 0.6.9.3
module Data.Foldable where
import Data.Foldable ()
import Prelude ()
import Data.Monoid ()
import Control.Apply ()
import Data.Monoid.First ()
import Prim ()
import Prelude ()
import Control.Apply ()
import Data.Either ()
import Data.Maybe ()
import Data.Monoid ()
import Data.Monoid.Additive ()
import Data.Monoid.Dual ()
import Data.Monoid.First ()
import Data.Monoid.Last ()
import Data.Monoid.Multiplicative ()
import Data.Tuple ()
--  | `Foldable` represents data structures which can be _folded_.
--  |
--  | - `foldr` folds a structure from the right
--  | - `foldl` folds a structure from the left
--  | - `foldMap` folds a structure by accumulating values in a `Monoid`
--  | `Foldable` represents data structures which can be _folded_.
--  |
--  | - `foldr` folds a structure from the right
--  | - `foldl` folds a structure from the left
--  | - `foldMap` folds a structure by accumulating values in a `Monoid`
--  | `Foldable` represents data structures which can be _folded_.
--  |
--  | - `foldr` folds a structure from the right
--  | - `foldl` folds a structure from the left
--  | - `foldMap` folds a structure by accumulating values in a `Monoid`
--  | Traverse a data structure, performing some effects encoded by an
--  | `Applicative` functor at each value, ignoring the final result.
--  |
--  | For example:
--  |
--  | ```purescript
--  | traverse_ print [1, 2, 3]
--  | ```
--  | A version of `traverse_` with its arguments flipped.
--  |
--  | This can be useful when running an action written using do notation
--  | for every element in a data structure:
--  |
--  | For example:
--  |
--  | ```purescript
--  | for_ [1, 2, 3] \n -> do
--  |   print n
--  |   trace "squared is"
--  |   print (n * n)
--  | ```
--  | Perform all of the effects in some data structure in the order
--  | given by the `Foldable` instance, ignoring the final result.
--  |
--  | For example:
--  |
--  | ```purescript
--  | sequence_ [ trace "Hello, ", trace " world!" ]
--  | ```
--  | `Foldable` represents data structures which can be _folded_.
--  |
--  | - `foldr` folds a structure from the right
--  | - `foldl` folds a structure from the left
--  | - `foldMap` folds a structure by accumulating values in a `Monoid`
--  | Fold a data structure, accumulating values in some `Monoid`,
--  | combining adjacent elements using the specified separator. 
--  | Fold a data structure, accumulating values in some `Monoid`.
--  | Test whether any `Boolean` value in a data structure is `true`.
--  | Find the product of the numeric values in a data structure.
--  | Find the sum of the numeric values in a data structure.
--  | `Foldable` represents data structures which can be _folded_.
--  |
--  | - `foldr` folds a structure from the right
--  | - `foldl` folds a structure from the left
--  | - `foldMap` folds a structure by accumulating values in a `Monoid`
--  | Lookup a value in a data structure of `Tuple`s, generalizing association lists.
--  | Fold a data structure, accumulating values in some `Monoid`.
--  | Try to find an element in a data structure which satisfies a predicate.
--  | Test whether a predicate holds for any element in a data structure.
--  | Test whether a value is an element of a data structure.
--  | Test whether a value is not an element of a data structure.
--  | Test whether all `Boolean` values in a data structure are `true`.
--  | Test whether a predicate holds for all elements in a data structure.
class Foldable f where
  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b
  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b
  foldMap :: forall a m. (Data.Monoid.Monoid m) => (a -> m) -> f a -> m
foreign import foldlArray :: forall a b. (b -> a -> b) -> b -> [a] -> b
foreign import foldrArray :: forall a b. (a -> b -> b) -> b -> [a] -> b
foreign import lookup :: forall a b f. (Prelude.Eq a, Data.Foldable.Foldable f) => a -> f (Data.Tuple.Tuple a b) -> Data.Maybe.Maybe b
foreign import find :: forall a f. (Data.Foldable.Foldable f) => (a -> Prim.Boolean) -> f a -> Data.Maybe.Maybe a
foreign import notElem :: forall a f. (Prelude.Eq a, Data.Foldable.Foldable f) => a -> f a -> Prim.Boolean
foreign import elem :: forall a f. (Prelude.Eq a, Data.Foldable.Foldable f) => a -> f a -> Prim.Boolean
foreign import product :: forall f. (Data.Foldable.Foldable f) => f Prim.Number -> Prim.Number
foreign import sum :: forall f. (Data.Foldable.Foldable f) => f Prim.Number -> Prim.Number
foreign import all :: forall a f. (Data.Foldable.Foldable f) => (a -> Prim.Boolean) -> f a -> Prim.Boolean
foreign import any :: forall a f. (Data.Foldable.Foldable f) => (a -> Prim.Boolean) -> f a -> Prim.Boolean
foreign import or :: forall f. (Data.Foldable.Foldable f) => f Prim.Boolean -> Prim.Boolean
foreign import and :: forall f. (Data.Foldable.Foldable f) => f Prim.Boolean -> Prim.Boolean
foreign import intercalate :: forall f m. (Data.Foldable.Foldable f, Data.Monoid.Monoid m) => m -> f m -> m
foreign import mconcat :: forall f m. (Data.Foldable.Foldable f, Data.Monoid.Monoid m) => f m -> m
foreign import sequence_ :: forall a f m. (Prelude.Applicative m, Data.Foldable.Foldable f) => f (m a) -> m Prelude.Unit
foreign import for_ :: forall a b f m. (Prelude.Applicative m, Data.Foldable.Foldable f) => f a -> (a -> m b) -> m Prelude.Unit
foreign import traverse_ :: forall a b f m. (Prelude.Applicative m, Data.Foldable.Foldable f) => (a -> m b) -> f a -> m Prelude.Unit
foreign import fold :: forall f m. (Data.Foldable.Foldable f, Data.Monoid.Monoid m) => f m -> m
foreign import instance foldableArray :: Data.Foldable.Foldable Prim.Array
foreign import instance foldableEither :: Data.Foldable.Foldable (Data.Either.Either a)
foreign import instance foldableMaybe :: Data.Foldable.Foldable Data.Maybe.Maybe
foreign import instance foldableTuple :: Data.Foldable.Foldable (Data.Tuple.Tuple a)
foreign import instance foldableAdditive :: Data.Foldable.Foldable Data.Monoid.Additive.Additive
foreign import instance foldableDual :: Data.Foldable.Foldable Data.Monoid.Dual.Dual
foreign import instance foldableFirst :: Data.Foldable.Foldable Data.Monoid.First.First
foreign import instance foldableLast :: Data.Foldable.Foldable Data.Monoid.Last.Last
foreign import instance foldableMultiplicative :: Data.Foldable.Foldable Data.Monoid.Multiplicative.Multiplicative
